using nor:2->1;

//
// 回路を定義する
//


// 定数

module true ()->(a) {
    a = not b;
    b = not a;
}

module false ()->(b) {
    a = not b;
    b = not a;
}

// 基本的なゲート

module buf (x)->(b) {
    a = not x;
    b = not a;
}

module not (x)->(a) {
    a = nor x x;
}

module and (x y)->(c) {
    a = not x  ;
    b = not y  ;
    c = nor a b;
}

module or (x y)->(b) {
    a = nor x y;
    b = not a  ;
}

module nand (x y)->(c) {
    a = not x  ;
    b = not y  ;
    c = or a b;
}

module xor (x y)->(e) {
    c = and x y;
    d = nor x y;
    e = nor c d;
}
module xnor (x y)->(b) {
    a = xor x y;
    b = not a  ;
}

// 多数決

module 3or (x y z)->(b) {
    a = or x y;
    b = or a z;
}

module 3and (x y z)->(b) {
    a = and x y;
    b = and a z;
}

module 4match (a b c d)->(bool) {
    a1 = and a b;
    c1 = and c d;
    a2 = or a b;
    c2 = or c d;
    ac2 = and a2 c2;
    bool = 3or a1 c1 ac2;
}

module 4even (a b c d)->(bool) {
    x = xnor a b;
    y = xnor c d;
    bool = xnor x y;
}
module 4odd (a b c d)->(bool) {
    x = xor a b;
    y = xor c d;
    bool = xor x y;
}

// circular dependency

module circular (x) -> (z) {
    z = nand z x;
}
module circular2 () -> (x) {
    a = not x;
    x = not b;
    b = not a;
}

// count

module 4or (a b c d) -> (bool) {
    x = or a b;
    y = or c d;
    bool = or x y;
}
module 4and (a b c d) -> (bool) {
    x = and a b;
    y = and c d;
    bool = and x y;
}
module 4count (a b c d) -> (x1 y2 z4) {
    a2 a1  = hAddr a b;
    c2 c1  = hAddr c d;
    q x1  = hAddr a1 c1;
    z4 r  = hAddr a2 c2;
    y2 = or q r;
}

// 加算器

module hAddr (x y)->(c s) {
    c = and x y;
    t = nor x y;
    s = nor c t;
}

module fAddr (x y z)->(c s1) {
    c0 s0 = hAddr x y  ;
    c1 s1 = hAddr s0 z ;
    c     = or    c0 c1;
}

// ラッチ回路

module sr_latch (s r)->(q nq) {
    nq = nor s q;
    q = nor r nq;
}

module d_latch (d clk)->(q nq) {
    nd = not d;
    s = nor nd clk;
    r = nor d clk;
    q nq = sr_latch s r;
}

// クロック回路

module clock()->(a) {
    a = buf b;
    b = not a;
}

// インパルス

module impulse()->(c) {
    c = not a;
    a = not b;
    b = not a;
}

// 8bit 回路
module 8nor(a0 a1 a2 a3 a4 a5 a6 a7 b0 b1 b2 b3 b4 b5 b6 b7)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 = nor a0 b0;
    o1 = nor a1 b1;
    o2 = nor a2 b2;
    o3 = nor a3 b3;
    o4 = nor a4 b4;
    o5 = nor a5 b5;
    o6 = nor a6 b6;
    o7 = nor a7 b7;
}
module 8buf(0 1 2 3 4 5 6 7)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 = buf 0;
    o1 = buf 1;
    o2 = buf 2;
    o3 = buf 3;
    o4 = buf 4;
    o5 = buf 5;
    o6 = buf 6;
    o7 = buf 7;
}
module 8not(0 1 2 3 4 5 6 7)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 = not 0;
    o1 = not 1;
    o2 = not 2;
    o3 = not 3;
    o4 = not 4;
    o5 = not 5;
    o6 = not 6;
    o7 = not 7;
}
module 8or(a0 a1 a2 a3 a4 a5 a6 a7
            b0 b1 b2 b3 b4 b5 b6 b7) ->
            (o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 = or a0 b0;
    o1 = or a1 b1;
    o2 = or a2 b2;
    o3 = or a3 b3;
    o4 = or a4 b4;
    o5 = or a5 b5;
    o6 = or a6 b6;
    o7 = or a7 b7;
}
module 8and(a0 a1 a2 a3 a4 a5 a6 a7
            b0 b1 b2 b3 b4 b5 b6 b7) ->
            (o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 = and a0 b0;
    o1 = and a1 b1;
    o2 = and a2 b2;
    o3 = and a3 b3;
    o4 = and a4 b4;
    o5 = and a5 b5;
    o6 = and a6 b6;
    o7 = and a7 b7;
}
module 8shiftr(0 1 2 3 4 5 6 7)->(o0 o1 o2 o3 o4 o5 o6 o7){
    o0 = false;
    o1 o2 o3 o4 o5 o6 o7 f = 8buf 0 1 2 3 4 5 6 o0;
}

module 8addr(a0 a1 a2 a3 a4 a5 a6 a7
            b0 b1 b2 b3 b4 b5 b6 b7) ->
            (o0 o1 o2 o3 o4 o5 o6 o7) {
    c0 o0 = hAddr a0 b0;
    c1 o1 = fAddr c0 a1 b1;
    c2 o2 = fAddr c1 a2 b2;
    c3 o3 = fAddr c2 a3 b3;
    c4 o4 = fAddr c3 a4 b4;
    c5 o5 = fAddr c4 a5 b5;
    c6 o6 = fAddr c5 a6 b6;
    c7 o7 = fAddr c6 a7 b7;
}

module 8sub(a0 a1 a2 a3 a4 a5 a6 a7 b0 b1 b2 b3 b4 b5 b6 b7) -> (o0 o1 o2 o3 o4 o5 o6 o7){
    nb0 nb1 nb2 nb3 nb4 nb5 nb6 nb7 = 8nagate b0 b1 b2 b3 b4 b5 b6 b7;
    o0 o1 o2 o3 o4 o5 o6 o7 = 8addr a0 a1 a2 a3 a4 a5 a6 a7 nb0 nb1 nb2 nb3 nb4 nb5 nb6 nb7;
}
module 8nagate(0 1 2 3 4 5 6 7)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    n0 n1 n2 n3 n4 n5 n6 n7 = 8not 0 1 2 3 4 5 6 7;
    o0 o1 o2 o3 o4 o5 o6 o7 = 8inc n0 n1 n2 n3 n4 n5 n6 n7;
}

// 2進数 to bit
module 1decoder (s)->(a b) {
    a = not  s;
    b = buf  s;
}
module 2decoder (s0 s1)->(a b c d) {
    ns0 = not s0;
    ns1 = not s1;
    a = nor s0 s1;
    b = nor ns0 s1;
    c = nor s0 ns1;
    d = nor ns0 ns1;
}
module 3nor(0 1 2) -> (o) {
    p = nor 0 1;
    o = nor p 2;
}
module 3decoder(a1 a2 a3)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    n1 = not a1;
    n2 = not a2;
    n3 = not a3;

    nor_n1n2 = nor n1 n2;
    nor_n12 = nor n1 a2;
    nor_1n2 = nor a1 n2;
    nor_12 = nor a1 a2;
    not_n1n2 = not nor_n1n2;
    not_n1a2 = not nor_n12;
    not_a1n2 = not nor_1n2;
    not_a1a2 = not nor_12;

    o0 = nor not_a1a2 a3;
    o1 = nor not_n1a2 a3;
    o2 = nor not_a1n2 a3;
    o3 = nor not_n1n2 a3;
    o4 = nor not_a1a2 n3;
    o5 = nor not_n1a2 n3;
    o6 = nor not_a1n2 n3;
    o7 = nor not_n1n2 n3;
}
// 8bitを流すかどうか
module 8switch(0 1 2 3 4 5 6 7 swc) -> (o0 o1 o2 o3 o4 o5 o6 o7) {
    o0 o1 o2 o3 o4 o5 o6 o7 = 8and 0 1 2 3 4 5 6 7 swc swc swc swc swc swc swc swc;
}
// #5
// ALU
module 6or(a0 a1 a2 a3 a4 a5)->(o) {
    p = 3or a0 a1 a2;
    q = 3or a3 a4 a5;
    o = or p q;
}
module ALU(a0 a1 a2
            b0 b1 b2 b3 b4 b5 b6 b7
            c0 c1 c2 c3 c4 c5 c6 c7) ->
            (o0 o1 o2 o3 o4 o5 o6 o7) {
    // Or Nand Nor And Add Sub
    t0 t1 t2 t3 t4 t5 f0 f1 = 3decoder a0 a1 a2;
    or0 or1 or2 or3 or4 or5 or6 or7 = 8or b0 b1 b2 b3 b4 b5 b6 b7 c0 c1 c2 c3 c4 c5 c6 c7;
    nb0 nb1 nb2 nb3 nb4 nb5 nb6 nb7 = 8not b0 b1 b2 b3 b4 b5 b6 b7;
    nc0 nc1 nc2 nc3 nc4 nc5 nc6 nc7 = 8not c0 c1 c2 c3 c4 c5 c6 c7;
    nand0 nand1 nand2 nand3 nand4 nand5 nand6 nand7 = 8or nb0 nb1 nb2 nb3 nb4 nb5 nb6 nb7 nc0 nc1 nc2 nc3 nc4 nc5 nc6 nc7;
    nor0 nor1 nor2 nor3 nor4 nor5 nor6 nor7 = 8nor b0 b1 b2 b3 b4 b5 b6 b7 c0 c1 c2 c3 c4 c5 c6 c7;
    and0 and1 and2 and3 and4 and5 and6 and7 = 8not nand0 nand1 nand2 nand3 nand4 nand5 nand6 nand7;
    // add sub
    d0 d1 d2 d3 d4 d5 d6 d7 = 8nagate c0 c1 c2 c3 c4 c5 c6 c7;
    e0 e1 e2 e3 e4 e5 e6 e7 = selector c0 c1 c2 c3 c4 c5 c6 c7 d0 d1 d2 d3 d4 d5 d6 d7 t4;
    add0 add1 add2 add3 add4 add5 add6 add7 = 8addr b0 b1 b2 b3 b4 b5 b6 b7 e0 e1 e2 e3 e4 e5 e6 e7;

    o00 o01 o02 o03 o04 o05 o06 o07 = 8switch or0 or1 or2 or3 or4 or5 or6 or7 t0;
    o10 o11 o12 o13 o14 o15 o16 o17 = 8switch nand0 nand1 nand2 nand3 nand4 nand5 nand6 nand7 t1;
    o20 o21 o22 o23 o24 o25 o26 o27 = 8switch nor0 nor1 nor2 nor3 nor4 nor5 nor6 nor7 t2;
    o30 o31 o32 o33 o34 o35 o36 o37 = 8switch and0 and1 and2 and3 and4 and5 and6 and7 t3;
    o40 o41 o42 o43 o44 o45 o46 o47 = 8switch add0 add1 add2 add3 add4 add5 add6 add7 t4;
    o50 o51 o52 o53 o54 o55 o56 o57 = 8switch add0 add1 add2 add3 add4 add5 add6 add7 t5;

    o0 = 6or o00 o10 o20 o30 o40 o50;
    o1 = 6or o01 o11 o21 o31 o41 o51;
    o2 = 6or o02 o12 o22 o32 o42 o52;
    o3 = 6or o03 o13 o23 o33 o43 o53;
    o4 = 6or o04 o14 o24 o34 o44 o54;
    o5 = 6or o05 o15 o25 o35 o45 o55;
    o6 = 6or o06 o16 o26 o36 o46 o56;
    o7 = 6or o07 o17 o27 o37 o47 o57;
}

// #4
// if switch A else B
module selector(a0 a1 a2 a3 a4 a5 a6 a7
                b0 b1 b2 b3 b4 b5 b6 b7
                switch) ->
                (0 1 2 3 4 5 6 7) {
    nswitch = not switch;
    00 01 02 03 04 05 06 07 = 8switch a0 a1 a2 a3 a4 a5 a6 a7 switch;
    10 11 12 13 14 15 16 17 = 8switch b0 b1 b2 b3 b4 b5 b6 b7 nswitch;
    0 1 2 3 4 5 6 7 = 8or 00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17;
}
// 入力と出力を選ぶ
module copyvalue(a0 a1 a2 a3 a4 a5 a6 a7
                b0 b1 b2 b3 b4 b5 b6 b7
                inswitch outswitch) ->
                (00 01 02 03 04 05 06 07
                10 11 12 13 14 15 16 17) {
    // 入力選択
    i0 i1 i2 i3 i4 i5 i6 i7 = selector a0 a1 a2 a3 a4 a5 a6 a7 b0 b1 b2 b3 b4 b5 b6 b7 inswitch;

    // 出力選択
    00 01 02 03 04 05 06 07 = 8switch i0 i1 i2 i3 i4 i5 i6 i7 outswitch;
    noutswitch = not outswitch;
    10 11 12 13 14 15 16 17 = 8switch i0 i1 i2 i3 i4 i5 i6 i7 noutswitch;

}

// メモリ
// wの間書き込み、rの間読み出し
module mem1bit (d, w,r)->(o) {
    nw = not w;
    q nq = d_latch d nw;
    o = and q r;
}
module mem8bits (d0 d1 d2 d3 d4 d5 d6 d7 w r)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    // nw = not w;
    o0 = mem1bit d0 w r;
    o1 = mem1bit d1 w r;
    o2 = mem1bit d2 w r;
    o3 = mem1bit d3 w r;
    o4 = mem1bit d4 w r;
    o5 = mem1bit d5 w r;
    o6 = mem1bit d6 w r;
    o7 = mem1bit d7 w r;
}

module mem4byte (d0 d1 d2 d3 d4 d5 d6 d7
                d8 d9 da db dc dd de df
                d10 d11 d12 d13 d14 d15 d16 d17
                d18 d19 d1a d1b d1c d1d d1e d1f
                w r) ->
                (o0 o1 o2 o3 o4 o5 o6 o7
                o8 o9 oa ob oc od oe of
                o10 o11 o12 o13 o14 o15 o16 o17
                o18 o19 o1a o1b o1c o1d o1e o1f) {
    o0 o1 o2 o3 o4 o5 o6 o7 = mem8bits d0 d1 d2 d3 d4 d5 d6 d7 w r;
    o8 o9 oa ob oc od oe of = mem8bits d8 d9 da db dc dd de df w r;
    o10 o11 o12 o13 o14 o15 o16 o17 = mem8bits d10 d11 d12 d13 d14 d15 d16 d17 w r;
    o18 o19 o1a o1b o1c o1d o1e o1f = mem8bits d18 d19 d1a d1b d1c d1d d1e d1f w r;
}
// sw0,1が保存メモリ先指定
// w_rがオンなら write, オフなら read
module mem8bit2(a0 a1 a2 a3 a4 a5 a6 a7 sw0 sw1 w_r) -> (
o0 o1 o2 o3 o4 o5 o6 o7 ) {
// o_a0 o_a1 o_a2 o_a3 o_a4 o_a5 o_a6 o_a7
// o_b0 o_b1 o_b2 o_b3 o_b4 o_b5 o_b6 o_b7
// o_c0 o_c1 o_c2 o_c3 o_c4 o_c5 o_c6 o_c7
// o_d0 o_d1 o_d2 o_d3 o_d4 o_d5 o_d6 o_d7
    sm0 sm1 sm2 sm3 = 2decoder sw0 sw1;   //memory selector
    w_sm0 = and w_r sm0;
    w_sm1 = and w_r sm1;
    w_sm2 = and w_r sm2;
    w_sm3 = and w_r sm3;

    nw_r = not w_r;
    r_sm0 = and nw_r sm0;
    r_sm1 = and nw_r sm1;
    r_sm2 = and nw_r sm2;
    r_sm3 = and nw_r sm3;
    o_a0 o_a1 o_a2 o_a3 o_a4 o_a5 o_a6 o_a7 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 w_sm0 r_sm0;  // memory 0
    o_b0 o_b1 o_b2 o_b3 o_b4 o_b5 o_b6 o_b7 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 w_sm1 r_sm1;  // memory 1
    o_c0 o_c1 o_c2 o_c3 o_c4 o_c5 o_c6 o_c7 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 w_sm2 r_sm2;  // memory 2
    o_d0 o_d1 o_d2 o_d3 o_d4 o_d5 o_d6 o_d7 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 w_sm3 r_sm3;  // memory 3
    o0 = 4or o_a0 o_b0 o_c0 o_d0;
    o1 = 4or o_a1 o_b1 o_c1 o_d1;
    o2 = 4or o_a2 o_b2 o_c2 o_d2;
    o3 = 4or o_a3 o_b3 o_c3 o_d3;
    o4 = 4or o_a4 o_b4 o_c4 o_d4;
    o5 = 4or o_a5 o_b5 o_c5 o_d5;
    o6 = 4or o_a6 o_b6 o_c6 o_d6;
    o7 = 4or o_a7 o_b7 o_c7 o_d7;
}

module mem12byte (d0 d1 d2 d3 d4 d5 d6 d7
                    d8 d9 da db dc dd de df
                    d10 d11 d12 d13 d14 d15 d16 d17
                    d18 d19 d1a d1b d1c d1d d1e d1f
                    d20 d21 d22 d23 d24 d25 d26 d27
                    d28 d29 d2a d2b d2c d2d d2e d2f
                    d30 d31 d32 d33 d34 d35 d36 d37
                    d38 d39 d3a d3b d3c d3d d3e d3f
                    d40 d41 d42 d43 d44 d45 d46 d47
                    d48 d49 d4a d4b d4c d4d d4e d4f
                    d50 d51 d52 d53 d54 d55 d56 d57
                    d58 d59 d5a d5b d5c d5d d5e d5f
                    w r) ->
                (o0 o1 o2 o3 o4 o5 o6 o7
                    o8 o9 oa ob oc od oe of
                    o10 o11 o12 o13 o14 o15 o16 o17
                    o18 o19 o1a o1b o1c o1d o1e o1f
                    o20 o21 o22 o23 o24 o25 o26 o27
                    o28 o29 o2a o2b o2c o2d o2e o2f
                    o30 o31 o32 o33 o34 o35 o36 o37
                    o38 o39 o3a o3b o3c o3d o3e o3f
                    o40 o41 o42 o43 o44 o45 o46 o47
                    o48 o49 o4a o4b o4c o4d o4e o4f
                    o50 o51 o52 o53 o54 o55 o56 o57
                    o58 o59 o5a o5b o5c o5d o5e o5f) {
    o0 o1 o2 o3 o4 o5 o6 o7
    o8 o9 oa ob oc od oe of
    o10 o11 o12 o13 o14 o15 o16 o17
    o18 o19 o1a o1b o1c o1d o1e o1f = mem4byte d0 d1 d2 d3 d4 d5 d6 d7
                                                d8 d9 da db dc dd de df
                                                d10 d11 d12 d13 d14 d15 d16 d17
                                                d18 d19 d1a d1b d1c d1d d1e d1f w r;
    o20 o21 o22 o23 o24 o25 o26 o27
    o28 o29 o2a o2b o2c o2d o2e o2f
    o30 o31 o32 o33 o34 o35 o36 o37
    o38 o39 o3a o3b o3c o3d o3e o3f = mem4byte d20 d21 d22 d23 d24 d25 d26 d27
                                                d28 d29 d2a d2b d2c d2d d2e d2f
                                                d30 d31 d32 d33 d34 d35 d36 d37
                                                d38 d39 d3a d3b d3c d3d d3e d3f w r;
    o40 o41 o42 o43 o44 o45 o46 o47
    o48 o49 o4a o4b o4c o4d o4e o4f
    o50 o51 o52 o53 o54 o55 o56 o57
    o58 o59 o5a o5b o5c o5d o5e o5f = mem4byte d40 d41 d42 d43 d44 d45 d46 d47
                                                d48 d49 d4a d4b d4c d4d d4e d4f
                                                d50 d51 d52 d53 d54 d55 d56 d57
                                                d58 d59 d5a d5b d5c d5d d5e d5f w r;
}

module 8inc (d0 d1 d2 d3 d4 d5 d6 d7)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    c = true;
    c0 o0 = hAddr d0 c;
    c1 o1 = hAddr d1 c0;
    c2 o2 = hAddr d2 c1;
    c3 o3 = hAddr d3 c2;
    c4 o4 = hAddr d4 c3;
    c5 o5 = hAddr d5 c4;
    c6 o6 = hAddr d6 c5;
    c7 o7 = hAddr d7 c6;
}
module counter ()->(o0 o1 o2 o3 o4 o5 o6 o7) {
    1 = true;
    0 = false;
    a0 a1 a2 a3 a4 a5 a6 a7 = 8inc o0 o1 o2 o3 o4 o5 o6 o7;
    o0 o1 o2 o3 o4 o5 o6 o7 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 1 1;
}

module counter_swc (i0 i1 i2 i3 i4 i5 i6 i7 swc)->(o0 o1 o2 o3 o4 o5 o6 o7) {
    1 = true;
    0 = false;
    nswc = not swc;
    a0 a1 a2 a3 a4 a5 a6 a7 = 8inc o0 o1 o2 o3 o4 o5 o6 o7;
    o00 o01 o02 o03 o04 o05 o06 o07 = mem8bits a0 a1 a2 a3 a4 a5 a6 a7 nswc nswc;
    o10 o11 o12 o13 o14 o15 o16 o17 = mem8bits i0 i1 i2 i3 i4 i5 i6 i7 swc swc;
    o0 o1 o2 o3 o4 o5 o6 o7 = 8or o00 o01 o02 o03 o04 o05 o06 o07 o10 o11 o12 o13 o14 o15 o16 o17;
}

// #5
// レジスタ
