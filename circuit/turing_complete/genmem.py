# 入力データ（複数行の文字列）
data = """-79 -78 69 -63 7 -62 -64 10 -61 -64 13 -60 -64 16 -59 -64
-58 -57 -79 -78 69 -63 -62 -61 27 -60 -64 30 -59 -64 33 -58
-64 36 -57 -64 -79 -78 69 42 -63 -64 45 -62 -64 48 -61 -64
51 -60 -64 54 -59 -64 57 -58 -64 60 -57 -64 63 54 -122 17
-122 42 -122 1 -122 27 -122 61 -122 17 -122 58 -122 -79 -78 13
-122 63 -122 29 -122 46 -122 10 -122 24 -122 3 -122 10 -122 -74
-122 -80 -127 -114 -126 106 -125 -98 -124 -90 -123 -82 -79 -120 -122 -118
-106 -117 -98 -116 -90 -115 -82 -78 -112 -122 -111 -114 -109 -98 -108 -90
-107 -82 -77 -104 -122 103 -114 102 -106 -100 -90 -99 -82 -76 -96 -122
-95 -114 -94 -106 -93 -98 -91 -82 -75 -88 -122 -87 -114 -86 -106 -85
-98 -84 -90 -79 -78 69 -98 -79 -78 68 -98 -79 -78 64 -98 -79
-78 69 -98 -79 -78 64 -98 -79 -78 69 -98 -79 -78 69 -98 -79
-78 68 -98 -79 -78 69 -98 -78 -108 -90 -77 -99 -82 -79 -117 -98
-79 -78 67 -98 -79 -78 67 -98 -75 -87 -114 -76 -91 -82 -79 -78
64 -98 -79 -78 69 -98 -77 -102 -106 -79 -118 -106 -79 -118 -106 -78
-111 -114 -79 -78 68 -98 -79 -78 64 -98 -77 -99 -82 -79 -78 64"""

# 各数値をリストに展開（トークンが連続している場合は3桁ずつに分割する処理は不要と仮定）
numbers = []
for token in data.split():
    try:
        numbers.append(int(token))
    except ValueError:
        print(f"変換できないトークン: {token}")


# 8ビットの2進数に変換（負の値の場合は2の補数表現にする）
def num_to_bin_spaced(n):
    # 負の数の場合は2の補数として扱う
    if n < 0:
        n = n & 0xFF
    bin_str = format(n, "08b")  # 8ビット表現
    return " ".join(list(bin_str))


# 各数値ごとにコード行を生成する
# 例: i00 i01 i02 i03 i04 i05 i06 i07 = 8switch 1 0 1 1 0 0 1 0 a00;
group_index = 0  # 連番で採番（ゼロ埋め2桁）
for n in numbers:
    bin_spaced = num_to_bin_spaced(n)  # "b0 b1 ... b7" の文字列
    # 左辺：iXX0 ～ iXX7 （XXはグループ番号）
    lhs = " ".join([f"i{group_index:02d}{bit}" for bit in range(8)])
    # コード行の生成
    code_line = f"{lhs} = 8switch {bin_spaced} a{group_index};"
    print(code_line)
    group_index += 1

print("\n# ここから、in0 ～ in7 を生成するコード")
# ここでは、先に生成した256個のグループ（例：i00～i255）があることを想定します。
# 今回の例ではグループ数は numbers の数だけですが、例として256個の場合のコードを示します。

# ※グループ数が不足している場合は適宜調整してください。
total_groups = 256  # 本来は256個のグループがあると仮定

for bit in range(8):
    # 各ビット位置 bit に対して、グループ番号 0～255 の i 変数を収集
    var_list = [f"i{idx:02d}{bit}" for idx in range(total_groups)]
    # 生成コード例: in0 = 256bit_or i00{bit} i01{bit} ... i255{bit};
    code_line = f"in{bit} = 256bit_or " + " ".join(var_list) + ";"
    print(code_line)
