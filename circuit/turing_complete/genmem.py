# 入力データ（複数行の文字列）
data = """182 134 176 129 142 130 150 131 158 132 166 133 174 177 136 134
138 150 139 158 140 166 141 174 178 144 134 145 142 147 158 148
166 149 174 179 152 134 153 142 154 150 156 166 157 174 180 160
134 161 142 162 150 163 158 165 174 181 168 134 169 142 170 150
171 158 172 166 177 178 65 158 177 178 67 158 177 178 69 158
177 178 67 158 177 178 67 158 177 178 69 158 177 178 66 158
177 178 66 158 177 178 64 158 177 178 65 158 177 178 67 158
179 154 150 177 178 67 158 181 168 134 179 156 166 177 178 67
158 177 178 64 158 177 141 174 180 160 134 177 178 65 158 176
130 150 177 178 69 158 177 139 158 177 178 65 158 177 178 66
158 176 130 150 181 170 150 177 178 65 158 177 141 174 181 170
150 181 170 150 177 178 69 158 177 178 65 158 177 178 67 158
177 178 64 158 177 178 68 158 179 157 174 179 157 174 181 168
134 178 144 134 180 165 174 177 178 69 158 177 178 66 158 177
178 65 158 177 178 67 158 177 178 69 158 180 162 150 177 178
69 158 177 178 68 158 177 178 64 158 177 139 158 177 178 68"""

# 数値リストを保持するリスト（1次元に展開）
numbers = []

# トークンごとに処理します
for line in data.splitlines():
    for token in line.split():
        try:
            # そのまま整数に変換できれば追加
            numbers.append(int(token))
        except ValueError:
            # 変換できない場合、トークンが連結された数値の可能性（各値は最大3桁と想定）
            if len(token) % 3 == 0:
                for i in range(0, len(token), 3):
                    part = token[i:i+3]
                    numbers.append(int(part))
            else:
                print(f"変換できないトークン: {token}")

# 数値を8ビット2進数（各桁空白区切り）に変換する関数
def num_to_bin_spaced(n):
    bin_str = format(n, '08b')  # 8ビット表現
    return " ".join(list(bin_str))

# 各数値ごとにコード行を生成する
# 生成されるコード行の例:
# i00 i01 i02 i03 i04 i05 i06 i07 = 8switch 1 0 1 1 0 0 1 0 a00;
group_index = 0  # 連番で採番（ゼロ埋め2桁）
for n in numbers:
    bin_spaced = num_to_bin_spaced(n)  # "b0 b1 ... b7" の文字列
    # 左辺：iXX0 ... iXX7 （XXはグループ番号）
    lhs = " ".join([f"i{group_index:02d}{bit}" for bit in range(8)])
    # 右辺：8switch の後に、変換した各ビット、最後に aXX;
    code_line = f"{lhs} = 8switch {bin_spaced} a{group_index};"
    print(code_line)
    group_index += 1
    
# 例: すでに 256 個のグループが生成されており、
# 各グループは iXX0, iXX1, ... iXX7 という名前になっているとします。

# in0～in7を生成
for bit in range(8):
    # 各ビット位置 bit に対して、グループ番号 0～255 の i 変数を収集
    var_list = [f"i{idx:02d}{bit}" for idx in range(256)]
    # 生成コード例: in0 = 256bit_or i00{bit} i01{bit} ... i255{bit};
    code_line = f"in{bit} = 256bit_or " + " ".join(var_list) + ";"
    print(code_line)
